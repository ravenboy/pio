/*
 * This code will format SD/SDHC/SDXC cards.
 * Warning all data will be deleted!
 *
 * This program attempts to match the format
 * generated by SDFormatter available here:
 *
 * http://www.sdcard.org/consumers/formatter/
 *
 * For very small cards this program uses FAT16
 * and the above SDFormatter uses FAT12.
 */
#include <arduino.h>

#include "SdFat.h"
#include "sdios.h"
#include "cout_io.h"

#ifdef ESP_32
#include "esp32_serial.h"
#endif

#include "sd_library.h"

bool sdFatOK = false;
#define SD_FAT_TYPE 3 //dont remove
// SD_FAT_TYPE = 0 for SdFat/File as defined in SdFatConfig.h,
// 1 for FAT16/FAT32, 2 for exFAT, 3 for FAT16/FAT32 and exFAT.
//#define SD_FAT_TYPE 0
/*
  Change the value of SD_CS_PIN if you are using SPI and
  your hardware does not use the default value, SS.
  Common values are:
  Arduino Ethernet shield: pin 4
  Sparkfun SD shield: pin 8
  Adafruit SD shields and modules: pin 10
*/
#ifndef SDCARD_SS_PIN
const uint8_t SD_CS_PIN = SS;
#else  // SDCARD_SS_PIN
// Assume built-in SD is used.
const uint8_t SD_CS_PIN = SDCARD_SS_PIN;
#endif  // SDCARD_SS_PIN

// Try max SPI clock for an SD. Reduce SPI_CLOCK if errors occur.
#define SPI_CLOCK SD_SCK_MHZ(50)
// Try to select the best SD card configuration.

#if HAS_SDIO_CLASS
#define SD_CONFIG SdioConfig(FIFO_SDIO)
#elif  ENABLE_DEDICATED_SPI
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SPI_CLOCK)
#else  // HAS_SDIO_CLASS
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SPI_CLOCK)
#endif  // HAS_SDIO_CLASS

const int8_t DISABLE_CHIP_SELECT = -1;

/*
  Set DISABLE_CS_PIN to disable a second SPI device.
  For example, with the Ethernet shield, set DISABLE_CS_PIN
  to 10 to disable the Ethernet controller.
*/
const int8_t DISABLE_CS_PIN = -1;
/*
  Change the value of SD_CS_PIN if you are using SPI
  and your hardware does not use the default value, SS.
  Common values are:
  Arduino Ethernet shield: pin 4
  Sparkfun SD shield: pin 8
  Adafruit SD shields and modules: pin 10
*/

// SDCARD_SS_PIN is defined for the built-in SD on some boards.
/*
#ifndef SDCARD_SS_PIN
const uint8_t SD_CS_PIN = SS;
#else   // SDCARD_SS_PIN
// Assume built-in SD is used.
const uint8_t SD_CS_PIN = SDCARD_SS_PIN;
#endif  // SDCARD_SS_PIN
*/

// Try max SPI clock for an SD. Reduce SPI_CLOCK if errors occur.
#define SPI_CLOCK SD_SCK_MHZ(50)

// Try to select the best SD card configuration.
#if HAS_SDIO_CLASS
#define SD_CONFIG SdioConfig(FIFO_SDIO)
#elif ENABLE_DEDICATED_SPI
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SPI_CLOCK)
#else  // HAS_SDIO_CLASS
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SPI_CLOCK)
#endif  // HAS_SDIO_CLASS


#if SD_FAT_TYPE == 0
SdFat sd;
File file;
File dir;
File root;
#elif SD_FAT_TYPE == 1
SdFat32 sd;
File32 file;
File32 root;
#elif SD_FAT_TYPE == 2
SdExFat sd;
ExFile file;
ExFile root;
#elif SD_FAT_TYPE == 3
SdFs sd;
FsFile file;
FsFile root;
#endif  // SD_FAT_TYPE

cid_t cid;
csd_t csd;
scr_t scr;
//uint8_t cmd6Data[64];
uint32_t eraseSize;
//uint32_t ocr;


extern MyOutStream cout;
uint32_t cardSectorCount = 0;
uint8_t  sectorBuffer[512];
// SdCardFactory constructs and initializes the appropriate card.
SdCardFactory cardFactory;
// Pointer to generic SD card.
SdCard* m_card = nullptr;

void printConfig(SdSpiConfig config) {
  if (DISABLE_CS_PIN < 0) { //DISABLE_CS_PIN default value is -1
    cout << F(
        "\nAssuming the SD is the only SPI device.\n"
        "Edit DISABLE_CS_PIN to disable an SPI device.\n");
  } else {
    cout << F("\nDisabling SPI device on pin ");
    cout << int(DISABLE_CS_PIN) << endl;
    pinMode(DISABLE_CS_PIN, OUTPUT);
    digitalWrite(DISABLE_CS_PIN, HIGH);
  }
  cout << F("\nAssuming the SD chip select pin is: ") << int(config.csPin);
  cout << F("\nEdit SD_CS_PIN to change the SD chip select pin.\n");
}

void PrintConfig(void){
  printConfig(SD_CONFIG);
}
//copied from Boardwalk code.
void _sdErrorHalt(SdCard* m_card) {
    Serial.println(F("_sdErrorHalt"));

    if (m_card->errorCode()) {
        if (m_card->errorCode() == SD_CARD_ERROR_CMD0) {

        Serial.println(F("No card, wrong chip select pin, or wiring error?\n")); 
        }
        Serial.print(F("SD errorCode: "));
        Serial.print((char*)hex);
        Serial.println((char*)showbase); 

        printSdErrorSymbol(&Serial, m_card->errorCode());
        Serial.print(F(" = "));
        Serial.println((int)m_card->errorCode());
        Serial.print(F("SD errorData = "));
        Serial.println((int)m_card->errorData());
        Serial.println(F("End Error.\n"));
    }
 
    while (true) {}
}
typedef const __FlashStringHelper *	FlashStringPtr;

void sdErrorHalt(void) {
  if (!m_card) {
    cout << F("Invalid SD_CONFIG.") << endl; //JBP NOTE trailing period
  } else if (m_card->errorCode()) {
    if (m_card->errorCode() == SD_CARD_ERROR_CMD0) {
      cout << F("No card, wrong chip select pin, or wiring error?") << endl; 
    }
    cout << F("SD errorCode: ") << hex << showbase; //JBP NOTE lacks trailing period
    printSdErrorSymbol(&Serial, m_card->errorCode());
    cout << F(" = ") << int(m_card->errorCode()) << endl;
    cout << F("SD errorData = ") << int(m_card->errorData()) << endl;

  }
  cout << F("End Error.\n");

  while (true) {}
}

void _sdError(SdCard* m_card, FlashStringPtr msg)                        
  {                                         
    Serial.print(msg); 
    _sdErrorHalt(m_card);                          
  }


#define sdError(msg) {cout << F("error: ") << F(msg) << endl; sdErrorHalt();}


//#define SPI_CLOCK SD_SCK_MHZ(50)
uint32_t const ERASE_SIZE = 262144L;

void eraseCard() {
  cout << endl << F("Erasing\n");
  uint32_t firstBlock = 0;
  uint32_t lastBlock;
  uint16_t n = 0;

  do {
    lastBlock = firstBlock + ERASE_SIZE - 1;
    if (lastBlock >= cardSectorCount) {
      lastBlock = cardSectorCount - 1;
    }
    if (!m_card->erase(firstBlock, lastBlock)) {
      sdError("erase failed");
    }
    cout << '.';
    if ((n++) % 64 == 63) {
      cout << endl;
    }
    firstBlock += ERASE_SIZE;
  } while (firstBlock < cardSectorCount);
  cout << endl;

  if (!m_card->readSector(0, sectorBuffer)) {
    sdError("readBlock");
  }
  cout << hex << showbase << setfill('0') << internal;
  cout << F("All data set to ") << setw(4) << int(sectorBuffer[0]) << endl;
  cout << dec << noshowbase << setfill(' ') << right;
  cout << F("Erase done\n");
}

void formatCard(void){

    SdCardFactory cardFactory;

    SdCard* m_card = nullptr;
    uint32_t cardSectorCount = 0;
    uint8_t  sectorBuffer[512];

    // Select and initialize proper card driver.
    //m_card = cardFactory.newCard(SD_CONFIG);
    m_card = cardFactory.newCard(SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(50)));
    
    if (!m_card || m_card->errorCode()) {
        _sdError(m_card,F("card init failed."));
        return;
    }

    cardSectorCount = m_card->sectorCount();
    if (!cardSectorCount) {
        _sdError(m_card, F("Get sector count failed."));
        return;
    }

    bool rtn ;
    if(cardSectorCount > 67108864){
        ExFatFormatter* exFatFormatter = new ExFatFormatter;
        rtn=exFatFormatter->format(m_card, sectorBuffer, &Serial);
        cout << F("2") << endl;

        delete exFatFormatter;

    }else{
        FatFormatter* fatFormatter = new FatFormatter;;

        rtn=fatFormatter->format(m_card, sectorBuffer, &Serial);
        delete fatFormatter;
    }

    if (!rtn) {
        _sdErrorHalt(m_card);
    }
    
}

bool Start_SD(const uint8_t chipSelect, bool permLoopIfFail /* = true */, uint32_t maxSck /* = SPI_HALF_SPEED */){
    //maxSck can be  SPI_HALF_SPEED, SPI_FULL_SPEED etc
    Serial.begin(BAUD_RATE);
    delay(3000);
    while(!Serial){}
    clearSerInput(Serial);
    DumpSer(Serial);

    cout << endl;
    cout << endl << F("Firmware - ") << SCRIPT_FRIENDLY_NAME <<  F(" version: ") << VERSIONSTR << endl;
    cout << F("Baud Rate: ") << BAUD_RATE << F("\n\n") ;
      
    // chicken and egg problem. baud rate is read,below, from the prefs file
    // so need to begin Serial with def baud rqte
    // so initErrorHalt can write to serial port
    sdFatOK = sd.begin(chipSelect, maxSck); 
    
    if (!sdFatOK){

      sd.initErrorPrint(&Serial); //dont call initErrorHalt,
      
      if(permLoopIfFail){
        cout << F("sd.begin() failed: permanent error loop") << endl;
        while(true){}
      }
    }

  return sdFatOK;  
}

//BEGIN SD QuickStart section 

void reformatMsg() {
  cout << F("Try reformatting the card.  For best results use\n");
  cout << F("the SdFormatter program in SdFat/examples or download\n");
  cout << F("and use SDFormatter from www.sdcard.org/downloads.\n");
}

void cardOrSpeed() {
  cout << F("Try another SD card or reduce the SPI bus speed.\n");
  cout << F("Edit SPI_SPEED in this program to change it.\n");
}

void DoSDQuickStart(void){
  #define SPI_SPEED SD_SCK_MHZ(4)

  if (DISABLE_CHIP_SELECT < 0) {
    cout << F(
        "\nBe sure to edit DISABLE_CHIP_SELECT if you have\n"
        "a second SPI device.  For example, with the Ethernet\n"
        "shield, DISABLE_CHIP_SELECT should be set to 10\n"
        "to disable the Ethernet controller.\n");
  }
  cout << F(
      "\nSD chip select is the key hardware option.\n"
      "Common values are:\n"
      "Arduino Ethernet shield, pin 4\n"
      "Sparkfun SD shield, pin 8\n"
      "Adafruit SD shields and modules, pin 10\n"
      "Unknown Maker ESP32 Pro S3, pin 34\n"     
      );
  cout << F("\nType any character to start\n");
  while (!Serial.available()) {
    yield();
  }
  int chipSelect;
  clearSerInput(Serial);
  //JBP the code below only supports one digit chip select numbers
  // and for this test SS is the default, 34 for UM PROS3
  #ifdef JBP_DONT_NEED
  
  cout << F("\nEnter the chip select pin number: ");
  while (!Serial.available()) {
    yield();
  }

  cin.readline();
  if (cin >> chipSelect) {
    cout << chipSelect << endl;
  } else {
    cout << F("\nInvalid pin number\n");
    return;
  }
  #else
  chipSelect = SS; //JBP 10/26/21 UM PROS3 SS is 34
  #endif
  
  cout << F("\nSD chip select pin is: ") << chipSelect;

  if (DISABLE_CHIP_SELECT < 0) {
    cout << F(
        "\nAssuming the SD is the only SPI device.\n"
        "Edit DISABLE_CHIP_SELECT to disable another device.\n");
  } else {
    cout << F("\nDisabling SPI device on pin ");
    cout << int(DISABLE_CHIP_SELECT) << endl;
    pinMode(DISABLE_CHIP_SELECT, OUTPUT);
    digitalWrite(DISABLE_CHIP_SELECT, HIGH);
  }
  if (!sd.begin(chipSelect, SPI_SPEED)) {
    if (sd.card()->errorCode()) {
      cout << F(
          "\nSD initialization failed.\n"
          "Do not reformat the card!\n"
          "Is the card correctly inserted?\n"
          "Is chipSelect set to the correct value?\n"
          "Does another SPI device need to be disabled?\n"
          "Is there a wiring/soldering problem?\n");
      cout << F("\nerrorCode: ") << hex << showbase;
      cout << int(sd.card()->errorCode());
      cout << F(", errorData: ") << int(sd.card()->errorData());
      cout << dec << noshowbase << endl;
      return;
    }
    cout << F("\nCard successfully initialized.\n");
    if (sd.vol()->fatType() == 0) {
      cout << F("Can't find a valid FAT16/FAT32/exFAT partition.\n");
      reformatMsg();
      return;
    }
    cout << F("Can't determine error type\n");
    return;
  }
  cout << F("\nCard successfully initialized.\n");
  cout << endl;

  uint32_t size = sd.card()->sectorCount();
  if (size == 0) {
    cout << F("Can't determine the card size.\n");
    cardOrSpeed();
    return;
  }
  uint32_t sizeMB = 0.000512 * size + 0.5;
  cout << F("Card size: ") << sizeMB;
  cout << F(" MB (MB = 1,000,000 bytes)\n");
  cout << endl;
  if (sd.fatType() <= 32) {
    cout << F("\nVolume is FAT") << int(sd.fatType());
  } else {
    cout << F("\nVolume is exFAT");
  }
  cout << F(", Cluster size (bytes): ") << sd.vol()->bytesPerCluster();
  cout << endl << endl;

  cout << F("Files found (date time size name):\n");
  sd.ls(LS_R | LS_DATE | LS_SIZE);

  if ((sizeMB > 1100 && sd.vol()->sectorsPerCluster() < 64) ||
      (sizeMB < 2200 && sd.vol()->fatType() == 32)) {
    cout << F("\nThis card should be reformatted for best performance.\n");
    cout << F("Use a cluster size of 32 KB for cards larger than 1 GB.\n");
    cout << F("Only cards larger than 2 GB should be formatted FAT32.\n");
    reformatMsg();
    return;
  }
}

//END SD QuickStart section 

//BEGIN SD Formar section 

void DoFormat(void){

    PrintConfig();
  
    // Select and initialize proper card driver.
    m_card = cardFactory.newCard(SD_CONFIG);
    if (!m_card || m_card->errorCode()) {
        sdError("Card init failed.");
        return;
    }

    cardSectorCount = m_card->sectorCount();
    if (!cardSectorCount) {
        sdError("Get sector count failed.");
        return;
    }

    cout << F("\nCard size: ") << cardSectorCount*5.12e-7;
    cout << F(" GB (GB = 1E9 bytes)\n");
    cout << F("Card size: ") << cardSectorCount/2097152.0;
    cout << F(" GiB (GiB = 2^30 bytes)\n");

    cout << F("Card will be formated ");
    if (cardSectorCount > 67108864) {
        cout << F("exFAT\n");
    } else if (cardSectorCount > 4194304) {
        cout << F("FAT32\n");
    } else {
        cout << F("FAT16\n");
    }
    
    //ulStart = millis();
    formatCard();
}

void DoInteractiveFormat(void){
  char c;
  PrintConfig();

  cout << F("\nType any character to start\n");
  while (!Serial.available()) {
    yield();
  }
  // Discard any extra characters.

  clearSerInput(Serial);

  cout << F(

    "This program can erase and/or format SD/SDHC/SDXC cards.\n"
        
    "\nSD chip select is the key hardware option.\n"
    "Common values are:\n"
    "\tArduino Ethernet shield, pin 4\n"
    "\tSparkfun SD shield, pin 8\n"
    "\tAdafruit SD shields and modules, pin 10\n"
    "\tUnknown Maker ESP32 Pro S3, pin 34\n"     
    "\n"
    "Erase uses the card's fast flash erase command.\n"
    "Flash erase sets all data to 0X00 for most cards\n"
    "and 0XFF for a few vendor's cards.\n"
    "\n"
    "Cards up to 2 GiB (GiB = 2^30 bytes) will be formated FAT16.\n"
    "Cards larger than 2 GiB and up to 32 GiB will be formatted\n"
    "FAT32. Cards larger than 32 GiB will be formatted exFAT.\n"
    "\n"
    "Warning, all data on the card will be erased.\n"
    "\nEnter 'Y' to continue:\n");

  while (!Serial.available()) {
    yield();
  }
  c = Serial.read();
  cout << c << endl;
  if (c != 'Y') {
    cout << F("Quiting, you did not enter 'Y'.\n");
    return;
  }
  // Read any existing Serial data.
  clearSerInput(Serial);

  // Select and initialize proper card driver.
  m_card = cardFactory.newCard(SD_CONFIG);
  if (!m_card || m_card->errorCode()) {
    sdError("card init failed.");
    return;
  }

  cardSectorCount = m_card->sectorCount();
  if (!cardSectorCount) {
    sdError("Get sector count failed.");
    return;
  }

  cout << F("\nCard size: ") << cardSectorCount*5.12e-7;
  cout << F(" GB (GB = 1E9 bytes)\n");
  cout << F("Card size: ") << cardSectorCount/2097152.0;
  cout << F(" GiB (GiB = 2^30 bytes)\n");

  cout << F("Card will be formated ");
  if (cardSectorCount > 67108864) {
    cout << F("exFAT\n");
  } else if (cardSectorCount > 4194304) {
    cout << F("FAT32\n");
  } else {
    cout << F("FAT16\n");
  }
  cout << F(
         "\n"
         "Options are:\n"
         "E - erase the card and skip formatting.\n"
         "F - erase and then format the card. (recommended)\n"
         "Q - quick format the card without erase.\n"
         "\n"
         "Enter option: ");

  while (!Serial.available()) {
    yield();
  }
  c = Serial.read();
  cout << c << endl;
  if (!strchr("EFQ", c)) {
    cout << F("Quiting, invalid option entered.") << endl;
    return;
  }
  if (c == 'E' || c == 'e') {
    eraseCard();
  }
  if (c == 'F' || c == 'Q') {
    formatCard();
  }

}
// END format section

//begin SD info section

void errorPrint() {
  if (sd.sdErrorCode()) {
    cout << F("SD errorCode: ") << hex << showbase;
    printSdErrorSymbol(&Serial, sd.sdErrorCode());
    cout << F(" = ") << int(sd.sdErrorCode()) << endl;
    cout << F("SD errorData = ") << int(sd.sdErrorData()) << endl;
  }
}

cid_t m_cid;
csd_t m_csd;
uint32_t m_ocr;

void printCardType() {
  cout << F("\nCard type: ");

  switch (sd.card()->type()) {
    case SD_CARD_TYPE_SD1:
      cout << F("SD1\n");
      break;

    case SD_CARD_TYPE_SD2:
      cout << F("SD2\n");
      break;

    case SD_CARD_TYPE_SDHC:
      if (csd.capacity() < 70000000) {
        cout << F("SDHC\n");
      } else {
        cout << F("SDXC\n");
      }
      break;

    default:
      cout << F("Unknown\n");
  }
}

bool dmpVol() {
  cout << F("\nScanning FAT, please wait.\n");
  int32_t freeClusterCount = sd.freeClusterCount();
  if (sd.fatType() <= 32) {
    cout << F("\nVolume is FAT") << int(sd.fatType()) << endl;
  } else {
    cout << F("\nVolume is exFAT\n");
  }
  cout << F("sectorsPerCluster: ") << sd.sectorsPerCluster() << endl;
  cout << F("fatStartSector:    ") << sd.fatStartSector() << endl;
  cout << F("dataStartSector:   ") << sd.dataStartSector() << endl;
  cout << F("clusterCount:      ") << sd.clusterCount() << endl;
  cout << F("freeClusterCount:  ");
  if (freeClusterCount >= 0) {
    cout << freeClusterCount << endl;
  } else {
    cout << F("failed\n");
    errorPrint();
    return false;
  }
  return true;
}

void hexDmp(void* reg, uint8_t size) {
  uint8_t* u8 = reinterpret_cast<uint8_t*>(reg);
  cout << hex << noshowbase;
  for (size_t i = 0; i < size; i++) {
    cout << setw(2) << setfill('0') << int(u8[i]);
  }
  cout << dec << endl;
}

void cidDmp() {
  cout << F("\nManufacturer ID: ");
  cout << uppercase << showbase << hex << int(cid.mid) << dec << endl;
  cout << F("OEM ID: ") << cid.oid[0] << cid.oid[1] << endl;
  cout << F("Product: ");
  for (uint8_t i = 0; i < 5; i++) {
    cout << cid.pnm[i];
  }
  cout << F("\nRevision: ") << cid.prvN() << '.' << cid.prvM() << endl;
  cout << F("Serial number: ") << hex << cid.psn() << dec << endl;
  cout << F("Manufacturing date: ");
  cout << cid.mdtMonth() << '/' << cid.mdtYear() << endl;
  cout << F("CID HEX: ");
  hexDmp(&cid, sizeof(cid));
}

void csdDmp() {
  eraseSize = csd.eraseSize();
  cout << F("\ncardSize: ") << 0.000512 * csd.capacity();
  cout << F(" MB (MB = 1,000,000 bytes)\n");

  cout << F("flashEraseSize: ") << int(eraseSize) << F(" blocks\n");
  cout << F("eraseSingleBlock: ");
  if (csd.eraseSingleBlock()) {
    cout << F("true\n");
  } else {
    cout << F("false\n");
  }
  cout << F("dataAfterErase: ");
  if (scr.dataAfterErase()) {
    cout << F("ones\n");
  } else {
    cout << F("zeros\n");
  }
  cout << F("CSD HEX: ");
  hexDmp(&csd, sizeof(csd));
}

bool mbrDmp() {
  MbrSector_t mbr;
  bool valid = true;
  if (!sd.card()->readSector(0, (uint8_t*)&mbr)) {
    cout << F("\nread MBR failed.\n");
    errorPrint();
    return false;
  }
  cout << F("\nSD Partition Table\n");
  cout << F("part,boot,bgnCHS[3],type,endCHS[3],start,length\n");
  for (uint8_t ip = 1; ip < 5; ip++) {
    MbrPart_t* pt = &mbr.part[ip - 1];
    if ((pt->boot != 0 && pt->boot != 0X80) ||
        getLe32(pt->relativeSectors) > csd.capacity()) {
      valid = false;
    }
    cout << int(ip) << ',' << uppercase << showbase << hex;
    cout << int(pt->boot) << ',';
    for (int i = 0; i < 3; i++) {
      cout << int(pt->beginCHS[i]) << ',';
    }
    cout << int(pt->type) << ',';
    for (int i = 0; i < 3; i++) {
      cout << int(pt->endCHS[i]) << ',';
    }
    cout << dec << getLe32(pt->relativeSectors) << ',';
    cout << getLe32(pt->totalSectors) << endl;
  }
  if (!valid) {
    cout << F("\nMBR not valid, assuming Super Floppy format.\n");
  }
  return true;
}

void DoSDInfo(bool interactive) {
  // Read any existing Serial data.
  printConfig(SD_CONFIG);

  clearSerInput(Serial);

  // F stores strings in flash to save RAM
  
  cout << F("SdFat version: ") << SD_FAT_VERSION_STR << endl;

  if(interactive){
    cout << F("type any character to start\n");
    while (!Serial.available()) {
      yield();
    }
  }
  
  uint32_t t = millis();
  if (!sd.cardBegin(SD_CONFIG)) {
    cout << F(
           "\nSD initialization failed.\n"
           "Do not reformat the card!\n"
           "Is the card correctly inserted?\n"
           "Is there a wiring/soldering problem?\n");
    if (isSpi(SD_CONFIG)) {
      cout << F(
           "Is SD_CS_PIN set to the correct value?\n"
           "Does another SPI device need to be disabled?\n"
           );
    }
    errorPrint();
    cout << F("\nSD Info Test volumeBegin failed. Is the card formatted?\n");

    return;
  }
  t = millis() - t;
  cout << F("init time: ") << t << " ms" << endl;

  if (!sd.card()->readCID(&m_cid) ||
      !sd.card()->readCSD(&m_csd) ||
      !sd.card()->readOCR(&m_ocr)) {
    cout << F("readInfo failed\n");
    errorPrint();
    return;
  }
  printCardType();
  cidDmp();
  csdDmp();
  cout << F("\nOCR: ") << uppercase << showbase;
  cout << hex << m_ocr << dec << endl;
  if (!mbrDmp()) {
    cout << F("\nSD Info Test mbrDmp() failed.\n");

    return;
  }
  if (!sd.volumeBegin()) {
    errorPrint();
    cout << F("\nSD Info Test volumeBegin failed. Is the card formatted?\n");
    return;
  }
  bool result = dmpVol(); //returns false if needs formatting.
  if(! result){
    cout << F("SD INFO: dmpVol FAILED, reformat card by uploading SD_Auto_Formatter or SD_Interactive_Formatter.\n");
  }
  cout << F("\nSD Info Test: ") << (result ? F("PASSED.\n") : F("FAILED.\n"));

}
//END SD info section

//BEGIN SD Benchmark section

void  error(const __FlashStringHelper *s){
    cout << s << F("\nExited\n") << endl;
    while(true){}
}

const bool PRE_ALLOCATE = true;

// Set SKIP_FIRST_LATENCY true if the first read/write to the SD can
// be avoid by writing a file header or reading the first record.
const bool SKIP_FIRST_LATENCY = true;

const uint32_t FILE_SIZE_MB = 5;

// Write pass count.
const uint8_t WRITE_COUNT = 2;

// Read pass count.
const uint8_t READ_COUNT = 2;
const uint32_t FILE_SIZE = 1000000UL*FILE_SIZE_MB;

const size_t BUF_SIZE = 512;
uint32_t buf32[(BUF_SIZE + 3)/4];
uint8_t* buf = (uint8_t*)buf32;

void DoSDBenchmark(bool interactive) {
  float s;
  uint32_t t;
  uint32_t maxLatency;
  uint32_t minLatency;
  uint32_t totalLatency;
  bool skipLatency;

  // Discard any input.
  clearSerInput(Serial);
  if(interactive){
    cout << F("\nType any character to start\n");
    while (!Serial.available()) {
      yield();
    }
  }

#if HAS_UNUSED_STACK
  cout << F("FreeStack: ") << FreeStack() << endl;
#endif  // HAS_UNUSED_STACK

  if (!sd.begin(SD_CONFIG)) {
    sd.initErrorHalt(&Serial);
  }
  if (sd.fatType() == FAT_TYPE_EXFAT) {
    cout << F("Type is exFAT") << endl;
  } else {
    cout << F("Type is FAT") << int(sd.fatType()) << endl;
  }

  cout << F("Card size: ") << sd.card()->sectorCount()*512E-9;
  cout << F(" GB (GB = 1E9 bytes)") << endl;

  cidDmp();

  // open or create file - truncate existing file.
  if (!file.open("bench.dat", O_RDWR | O_CREAT | O_TRUNC)) {
    error(F("open failed"));
  }

  // fill buf with known data
  if (BUF_SIZE > 1) {
    for (size_t i = 0; i < (BUF_SIZE - 2); i++) {
      buf[i] = 'A' + (i % 26);
    }
    buf[BUF_SIZE-2] = '\r';
  }
  buf[BUF_SIZE-1] = '\n';

  cout << F("FILE_SIZE_MB = ") << FILE_SIZE_MB << endl;
  cout << F("BUF_SIZE = ") << BUF_SIZE << F(" bytes\n");
  cout << F("Starting write test, please wait.") << endl << endl;

  // do write test
  uint32_t n = FILE_SIZE/BUF_SIZE;
  cout <<F("write speed and latency") << endl;
  cout << F("speed,max,min,avg") << endl;
  cout << F("KB/Sec,usec,usec,usec") << endl;
  for (uint8_t nTest = 0; nTest < WRITE_COUNT; nTest++) {
    file.truncate(0);
    if (PRE_ALLOCATE) {
      if (!file.preAllocate(FILE_SIZE)) {
        error(F("preAllocate failed"));
      }
    }
    maxLatency = 0;
    minLatency = 9999999;
    totalLatency = 0;
    skipLatency = SKIP_FIRST_LATENCY;
    t = millis();
    for (uint32_t i = 0; i < n; i++) {
      uint32_t m = micros();
      if (file.write(buf, BUF_SIZE) != BUF_SIZE) {
        error(F("write failed"));
      }
      m = micros() - m;
      totalLatency += m;
      if (skipLatency) {
        // Wait until first write to SD, not just a copy to the cache.
        skipLatency = file.curPosition() < 512;
      } else {
        if (maxLatency < m) {
          maxLatency = m;
        }
        if (minLatency > m) {
          minLatency = m;
        }
      }
    }
    file.sync();
    t = millis() - t;
    s = file.fileSize();
    cout << s/t <<',' << maxLatency << ',' << minLatency;
    cout << ',' << totalLatency/n << endl;
  }
  cout << endl << F("Starting read test, please wait.") << endl;
  cout << endl <<F("read speed and latency") << endl;
  cout << F("speed,max,min,avg") << endl;
  cout << F("KB/Sec,usec,usec,usec") << endl;

  // do read test
  for (uint8_t nTest = 0; nTest < READ_COUNT; nTest++) {
    file.rewind();
    maxLatency = 0;
    minLatency = 9999999;
    totalLatency = 0;
    skipLatency = SKIP_FIRST_LATENCY;
    t = millis();
    for (uint32_t i = 0; i < n; i++) {
      buf[BUF_SIZE-1] = 0;
      uint32_t m = micros();
      int32_t nr = file.read(buf, BUF_SIZE);
      if (nr != BUF_SIZE) {
        error(F("read failed"));
      }
      m = micros() - m;
      totalLatency += m;
      if (buf[BUF_SIZE-1] != '\n') {

        error(F("data check error"));
      }
      if (skipLatency) {
        skipLatency = false;
      } else {
        if (maxLatency < m) {
          maxLatency = m;
        }
        if (minLatency > m) {
          minLatency = m;
        }
      }
    }
    s = file.fileSize();
    t = millis() - t;
    cout << s/t <<',' << maxLatency << ',' << minLatency;
    cout << ',' << totalLatency/n << endl;
  }
  file.close();
}

//END SD Benchmark section

//BEGIN SD DirFuncs section

void DoSDDirFuncs(bool interactive){
  if(interactive){
    cout << F("\nType any character to start\n");
    while (!Serial.available()) {
      yield();
    }
  }
  char dirName[20];
  ltoa(micros(),dirName,10);

  cout << F("\n\nDirectory Functions Test Directory Name: \"") <<dirName << F("\"\n");
  bool bDirfuncsPassed = true;
  char filePath1[50];
  char filePath2[50];
  strcpy(filePath1,dirName);
  strcat_P(filePath1,(PGM_P) F("/file1.txt"));
  strcpy(filePath2,dirName);
  strcat_P(filePath2,(PGM_P) F("/file2.txt"));
 
  char dirPath[50];
  strcpy_P(dirPath,(PGM_P)F("/"));
  strcat(dirPath,dirName);

  if (sd.exists(dirName)
    || sd.exists(filePath1)
    || sd.exists(filePath1)) {
    
    cout << dirName << F(" exists\n");

    FatFile ff(dirPath,O_READ);

    if (! ff.isOpen()){
      error(F("FatFile init failed.\n"));
      
    }

    if(!ff.rmRfStar()){
       error(F("rmRfStar root dir failed.\n"));
    }

    cout << F("rmRfStar Folder1 removed\n");

  }else{
    cout << F("The directory \"") << dirName << F("\" does not exist\n");
  }
  sd.chdir();

  // Create a new folder.
  if (!sd.mkdir(dirName)) {
    error(F("\n\nCreate root dir failed"));
    bDirfuncsPassed = false;
  }
  cout << F("Created directory \"") << dirName << F("\"\n");

  // Create a file in Folder1 using a path.
  if (!file.open(filePath1, O_WRONLY | O_CREAT)) {
    error(F("create root dir/file1.txt failed"));
    bDirfuncsPassed = false;
  }
  file.close();
  cout << F("Created file \"") << filePath1 << F("\"\n");

  // Change volume working directory to Folder1.
  if (!sd.chdir(dirName)) {
    error(F("chdir failed for new root dir.\n"));
    bDirfuncsPassed = false;
  }
  cout << F("chdir to \"") << dirName << F("\"\n");

  // Create File2.txt in current directory.
  if (!file.open("File2.txt", O_WRONLY | O_CREAT)) {
    error(F("create file \"File2.txt\" failed"));
    bDirfuncsPassed = false;
  }
  file.close();
  cout << F("Created file \"File2.txt\" in directory \"") << dirName << F("\"\n");

  cout << F("\nList of files on the SD.\n");
  sd.ls("/", LS_R);
  cout << F("\nEnd of List of files on the SD.\n");

  // Remove files from current directory.
#ifndef rmRfStar_test
  if (!sd.remove("file1.txt") || !sd.remove("File2.txt")) {
    error(F("remove failed"));
    bDirfuncsPassed = false;
  }
  cout << F("\nfile1.txt and File2.txt removed.\n");
// Change current directory to root.
  if (!sd.chdir()) {
    error(F("chdir to root failed.\n"));
    bDirfuncsPassed = false;
  }

  cout << F("\nList of files on the SD.\n");
  sd.ls(LS_R);
  cout << F("\nEnd of List of files on the SD.\n");

  // Remove Folder1.
  if (!sd.rmdir(dirName)) {
    error(F("rmdir for root dir failed\n"));
    bDirfuncsPassed = false;
  }
  cout << F("\nDirectyory \"") << dirName << F("\" removed.\n");
#else
  //if (!sd.chdir()){
  //    error(F("chdir to Folder1 failed.\n"));

 //   }
  FatFile ff2(dirPath,O_READ);
  if(!ff2.rmRfStar()){
      
    error(F("ending: rmRfStar root dir failed.\n"));

  }
  cout << F("ending: \"")<< dirPath << F("\"rmRfStar removed");

#endif

  cout << F("\nList of files on the SD.\n");
  sd.ls(LS_R);
  cout << F("\nEnd of List of files on the SD.\n");

  cout << F("\nDirectory Functions Test: ") << (bDirfuncsPassed ? F("PASSED.\n") : F("FAILED.\n"));

}
//END SD DirFuncs section

//BEGIN SD OpenNext section

void DoSDOpenNext(bool interactive){
  File dir;

  if(interactive){
    cout << F("\nType any character to start\n");
    while (!Serial.available()) {
      yield();
    }
  }

  clearSerInput(Serial);

  // Open root directory
  if (!dir.open("/")){
    error(F("dir.open failed\n"));
  }
  // Open next file in root.
  // Warning, openNext starts at the current position of dir so a
  // rewind may be necessary in your application.
  while (file.openNext(&dir, O_RDONLY)) {
    file.printFileSize(&Serial);
    Serial.write(' ');
    file.printModifyDateTime(&Serial);
    Serial.write(' ');
    file.printName(&Serial);
    if (file.isDir()) {
      // Indicate a directory.
      Serial.write('/');
    }
    Serial.println();
    file.close();
  }
  if (dir.getError()) {
    cout << F("openNext failed\n");
  } 

}
//END SD OpenNext section


void SendSDFatState(void){
    if(sdFatOK){
      cout << F("\nStarting SendSDFatState\n");
    }else{
      cout << F("\nSDFat begin failed\n") << endl;
      cout << F("Not Starting SendSDFatState") << endl;
      return;
    }

    char pPath[eLEN_MAX_PATH_LENGTH];
    SdFile file;
    const __FlashStringHelper *state = F("SDFat state: ");
    const __FlashStringHelper *notexist = F(" does not exist"); 
    const __FlashStringHelper *exists = F(" exists");

    //const __FlashStringHelper *gfsrootpath =F("GFS Root Path ");

    const __FlashStringHelper *profileLabel= F("GFS Root Dir ") ;
    const __FlashStringHelper *prefsFileLabel = F("Boardwalk Preferences File ") ;
    const __FlashStringHelper *iniFileLabel = F("INI File ") ;
    const __FlashStringHelper *afterIniFileLabel = F("AFTER INI File ") ;
    const __FlashStringHelper *scrFile = F("source file ") ;

    const __FlashStringHelper *profileFilePath = F("BW_PREFS/PROFILE.TXT"); 
    const __FlashStringHelper *bwPrefsPath = F("BW_PREFS/BW_PREFS.TXT"); 
    const __FlashStringHelper *iniPath = F("BW_PREFS/INI.TXT"); 
    const __FlashStringHelper *afteriniPath = F("BW_PREFS/AFTER_INI.TXT"); 

    const __FlashStringHelper *pathList[] = {profileFilePath,bwPrefsPath,iniPath,afteriniPath};
    const int lengths[] = {eLen_PREFS_FILE_PATH,eLEN_MAX_PATH_LENGTH,eLEN_MAX_PATH_LENGTH,eLEN_MAX_PATH_LENGTH};
    const __FlashStringHelper *labels[] ={profileLabel,prefsFileLabel,iniFileLabel, afterIniFileLabel};

    for (int i = 0; i <= 3; i++){
      //cout << i << endl;
      strcpy_P(pPath,(const char*)pathList[i]);

      if (file.open(pPath, O_READ )) {
          int size = file.fileSize();
          cout << endl << state << scrFile << pPath << exists << endl;
          
          file.read(pPath,size > lengths[i]-1 ? lengths[i]-1:size) ;
          pPath[size]='\0';
          //cout<< F("read: ") << pPath << endl;
          file.close();

          if (sd.exists(&pPath[1])){ // the paths in the files have a forward slash
            cout << state  << labels[i] << pPath << exists << endl;
          }else{
            cout << state << labels[i] << pPath << notexist << endl;
          }

      }else{
          // /BW_PREFS/PROFILE.TXT DOES NOT EXIST
          cout << ("\n") << state << pPath << notexist << endl;
          cout << state  << labels[i] << pPath << notexist << endl;

      }
    }

}

//BEGIN Utility section

bool SetupFile(const char* dirName, const char* filename){
  /***
   * 
   * SetupFile(const char* dirName, const char* filename)
   *   removes the dir if it exists
   *   example:
   *      SetupFile("Temp", "Tempfile.txt");
   */

  char filePath[50];

  strcpy(filePath,dirName);
  strcat_P(filePath,(PGM_P) F("/"));
  strcat(filePath,filename);

  char dirPath[20];
  strcpy_P(dirPath,(PGM_P)F("/"));
  strcat(dirPath,dirName);
  
  if (sd.exists(dirName)) {
    
    cout << dirName << F(" exists\n");

    FatFile ff(dirPath,O_READ);

    if (! ff.isOpen()){
      cout << (F("FatFile init failed.\n"));
      return false;
    }

    if(!ff.rmRfStar()){
      cout << F("rmRfStar of ") << dirName << F(" directory failed.") << endl;
      return false;
    }

    cout << dirPath << F(" has been removed\n");

  }else{
    cout << F("The directory \"") << dirName << F("\" does not exist\n");
  }
  sd.chdir();

  // Create a new folder.
  if (!sd.mkdir(dirName)) {
    cout << (F("\n\nCreate root dir failed")) << endl;
    return false;
  }
  cout << F("Created directory \"") << dirName << F("\"\n");

  // Create a file in Folder1 using a path.
  if (!file.open(filePath, O_WRONLY | O_CREAT)) {
    cout << F("create ") << filePath << F("failed") << endl;
    return false;
  }else{
    cout << F("create ") << filePath << F(" succeeded") << endl;
  }

  return true;
}



